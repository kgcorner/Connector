{
  "_args": [
    [
      {
        "raw": "pods@^2.0.0",
        "scope": null,
        "escapedName": "pods",
        "name": "pods",
        "rawSpec": "^2.0.0",
        "spec": ">=2.0.0 <3.0.0",
        "type": "range"
      },
      "/work/open-source/Connector/Server2"
    ]
  ],
  "_from": "pods@>=2.0.0 <3.0.0",
  "_id": "pods@2.0.0",
  "_inCache": true,
  "_location": "/pods",
  "_npmUser": {
    "name": "gmacwilliam",
    "email": "gmacwill77@gmail.com"
  },
  "_npmVersion": "1.2.17",
  "_phantomChildren": {},
  "_requested": {
    "raw": "pods@^2.0.0",
    "scope": null,
    "escapedName": "pods",
    "name": "pods",
    "rawSpec": "^2.0.0",
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/pods/-/pods-2.0.0.tgz",
  "_shasum": "212173c7855eb3104cc753159f8b45187ae945c2",
  "_shrinkwrap": null,
  "_spec": "pods@^2.0.0",
  "_where": "/work/open-source/Connector/Server2",
  "author": {
    "name": "Greg MacWilliam"
  },
  "bugs": {
    "url": "https://github.com/gmac/pods.js/issues"
  },
  "dependencies": {},
  "description": "Tiny managers for module definition and dependency management.",
  "devDependencies": {
    "chai": "~1.8.1",
    "grunt": "~0.4.2",
    "grunt-contrib-uglify": "~0.2.7",
    "mocha": "~1.16.2",
    "sinon": "~1.7.3",
    "underscore": "~1.5.2"
  },
  "directories": {},
  "dist": {
    "shasum": "212173c7855eb3104cc753159f8b45187ae945c2",
    "tarball": "https://registry.npmjs.org/pods/-/pods-2.0.0.tgz"
  },
  "gitHead": "6421505f6489c3cefc85e73c5849592460f9f446",
  "homepage": "https://github.com/gmac/pods.js#readme",
  "keywords": [
    "module",
    "dependency",
    "management"
  ],
  "license": "MIT",
  "main": "pods.js",
  "maintainers": [
    {
      "name": "gmacwilliam",
      "email": "gmacwill77@gmail.com"
    }
  ],
  "name": "pods",
  "optionalDependencies": {},
  "readme": "# Pods.js\n\nPods.js is a tiny synchronous module definition and dependency management library, built around a familiar define/require interface. Pods are designed to provide a light-weight manager for organizing collections of related module components. Pods are a great way to break up a large compiled application codebase into managed modules. The synchronous nature of Pods also makes their benefits orthogonal to that of an AMD system such as RequireJS; it can still be useful to break down large AMD application modules into locally-scoped component clusters.\n\nThe `Pod` API has three methods: `define`, `declare`, and `require`. Pods may be instanced, each instance will manage its own collection of modules. Modules may also be managed through the static `Pod` interface.\n\n```javascript\n// Manage using constructed pod instances:\nvar p = new Pod();\np.define(\"module\", {});\np.declare(\"jquery\", $);\np.require(\"module\");\n\n// Manage through the static library instance:\nPod.define(\"module\", {});\nPod.declare(\"jquery\", $);\nPod.require(\"module\");\n```\n\nNote that all `Pod` instances and the static `Pod` object will each manage their own unique module collections. A module defined in one Pod instance will not be available to other Pods.\n\n## define()\n\nThe `define` method creates a module definition.\t\n\n```javascript\nPod.define( \"moduleId\", [dependencies]?, exports );\n```\n\n- `\"moduleId\"` : *Required*. Unique string identifier for this module.\n- `[dependencies]?` : *Optional*. Array of dependency module ids to be required and injected into the module's scope.\n- `exports` : *Required*. An export object for the module, or a factory function used to build the module export. A factory function should receive arguments mapped to the module's dependencies.\n\nThe complete usage of `define` allows:\n\n```javascript\nvar p = new Pod();\n\n// 1) Define a module with a plain exports object.\np.define(\"module\", {});\n\n// 2) Define a module with a factory function.\np.define(\"module1\", function() {\n\treturn {};\n});\n\n// 3) Define a module with a single dependency and factory function.\np.define(\"module2\", [\"module1\"], function( mod1 ) {\n\treturn {};\n});\n\n// 4) Define a module with multiple dependencies and a factory function.\np.define(\"main\", [\"module1\", \"module2\"], function( mod1, mod2 ) {\n\treturn {};\n});\n\n// Require a module to load it...\np.require(\"main\");\n```\n\nWhile listing module dependencies, you may include `\"pod\"` as an identifier to have the managing Pod instance provide a reference to itself:\n\n```javascript\nvar p = new Pod();\n\np.require([\"pod\"], function( pod ) {\n\tconsole.log(pod === p); // true\n});\n```\n\nModules may be defined in any order, however, all `define` calls should precede your first `require` call. A good practice is to define a `\"main\"` module for launching your application, and then require `\"main\"` as your final line of code. For example, here's a simple modular application pattern:\n\n```javascript\n// 1) Create an application scope and pod instance...\n(function() {\n\tvar p = new Pod();\n\t\n\t// 2) Define all application modules...\n\tp.define(\"module1\", function() {\n\t\treturn {};\n\t});\n\t\n\tp.define(\"module2\", function() {\n\t\treturn {};\n\t});\n\t\n\t// 3) Define a \"main\" module used to launch your app...\n\tp.define(\"main\", [\"module1\", \"module2\"], function( mod1, mod2 ) {\n\t\t// Launch application!\n\t});\n\t\n\t// 4) Require \"main\"...\n\tp.require(\"main\");\n}());\n```\n\n## declare()\n\nThe `declare` method is a convenient way to quickly define one or more object literals. When using `declare`, functions will be treated as export objects rather than as factory functions. Use this method to safely declare third-party libraries as managed modules.\n\n```javascript\nPod.declare( \"moduleId\", exports );\n// OR:\nPod.declare( exportsMap );\n```\n\n- `\"moduleId\"` : Unique string identifier for the declared module.\n- `exports` : An export object for the module. The provided object will be set as the module's definitive export value; if a function is provided as the export, it will be preserved rather than being used as the module's factory.\n- `exportsMap` : An object with key-value pairs mapping multiple module ids to their related exports.\n\nThe complete usage of `declare` allows:\n\n```javascript\nvar p = new Pod();\n\n// 1) Safely declare any object type (including functions/libraries) as module exports.\n// (note that the root jQuery object is a *function*...)\np.declare(\"jquery\", $);\n\n// 2) Declare multiple exports as a map of key-value pairs.\np.declare({\n\t\"backbone\": Backbone,\n\t\"jquery\": $,\n\t\"underscore\": _\n});\n```\n\nWhy `declare` third-party libraries rather than using `define`? jQuery is a great example: the root jQuery object is actually a function. In order to define jQuery, we'd need to wrap it in a factory function to safely export it. The `declare` method does this for us, like so:\n\n```javascript\nPod.define(\"jquery\", function() {\n\treturn $;\n});\n\n// is identical to...\n\nPod.declare(\"jquery\", $);\n```\n\n## require()\n\nThe `require` method builds/accesses a module or collection of modules. Modules and their dependencies are built the first time they are required. Built modules are returned by the `require` method, *and* injected into an optional callback.\n\n```javascript\nvar module = Pod.require( [\"moduleId\"], callbackFunction? );\n```\n\n- `[\"moduleId\"]` : *Required*. The string identifier of a single module, *or* an array of module ids.\n- `callbackFunction?` : *Optional*. Callback function into which the required modules are injected. Provide mapped arguments.\n- `return` : A single module is returned when a single id string is required; an array of modules is returned when an array of module ids are required.\n\nThe complete usage of `require` allows:\n\n```javascript\nvar p = new Pod();\np.define('module1', {});\np.define('module2', {});\n\n// 1) Return a single module by direct id reference.\nvar module = p.require('module1');\n\n// 2) Inject a single module as an argument of a callback function.\np.require('module1', function( mod1 ) {\n\t// do stuff.\n});\n\n// 3) Return an array of modules mapped to a list of required ids.\nvar moduleArray = p.require(['module1', 'module2']);\n\n// 4) Inject a collection of modules as arguments of a callback function.\np.require(['module1', 'module2'], function( mod1, mod2 ) {\n\t// do stuff.\n});\n\n// 5) OR, do all of the above... return AND inject one or more modules with a single require call.\nvar moduleArray = p.require(['module1', 'module2'], function( mod1, mod2 ) {\n\t// do stuff.\n});\n```\n\nWhich came first, the chicken or the egg? Pods do not care to figure it out, so they'll throw an exception when a circular reference is required. Avoid circular references; you should be rethinking your organization anyway if you encounter this problem.\n\n## Notes\n\n- Support for elevating MMD/Pods methods to global scope has been officially deprecated as of version 2. Pods are specifically intended to be used as instances.\n\n- Happy building, and have fun!\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/gmac/pods.js.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "2.0.0"
}
